<!--
假设读者已经了解了一点内容, 不然要讲的东西太多了
面向知识本身吧, 不然太难写了
讲到直接光照

## 蒙特卡洛积分
-->

# pbrt-v3 阅读笔记(一): 基础概念

root.jpg

本篇文章说是对 pbr 的阅读笔记, 笔者也想借此用自己的理解来讲讲"基于物理的渲染"是什么一回事, 以及对这本书的阅读建议. 以下内容假设读者有对图形渲染(如 Phong 着色模型, 针孔相机, 点光源), 光线跟踪算法的基本了解, 因此一些基本概念就略过不讲了. 但还未接触过基于物理的渲染(光谱, 辐射度, 亮度, BRDF, 反射方程, 光线传输方程), 

pbrt 里有很多优化, 初学的时候要避开
如果有阅读 <> 过书籍, 课程, 对 pbr 的基本概念有了解, 就更好了

限于篇幅, 这里没有介绍光线投射(ray cast), 递归光线跟踪(), 随机光线跟踪() 等内容

## 经典的 Phong 光照模型(向量, 矩阵, 坐标/空间变换, 相机, 图像)

## 简单的光线跟踪程序(光线跟踪, 光线-对象相交, )

回顾一个简单的光线跟踪实例, 我们会设置一个场景(scene), 场景中包含相机(camera), 若干个光源(lights)和要渲染的模型(models)

图一:

```C++
// 一个典型的例子 raytracing_v1:

class Camera;
class Model;
class Light;

class Scene
{
    Camera camera;
    Model  models[];
    Light  lights[];
};

class Renderer
{
    void render(const Scene& scene);
};
```

很多简化, 假设, 在一开始学习时是有帮助的, 就好像我们中学时学的是牛顿三大定律而非相对论, 几何光学而非波动光学一样, 可以

如果把这个程序和现实世界联系在一起, 会发现它有很多不足之处(或者说过于理想): 

- 光源是理想化的一个点, 而现实中最为广泛的是面积(和体积光源); 
- 着色计算中假设模型表面的漫反射是完美漫反射, 光泽反射是完美镜面反射;
- 模型表面的着色计算过于简单, 能表达的材质种类太少; 

在刚开始接触图形渲染时, 这些简化处理是可以帮助隐藏细节, 理解主要原理的. 但是当我们希望渲染出更真实的图像时, 这些简化处理就限制了渲染器的表现能力. 那么很自然的, 如果我们能让渲染器(的各个组件)更真实去模拟现实环境中的效果, 也就是基于实际的物理法则去实现这个渲染器, 也许就能产生更为逼真的效果, 实际上也确实如此. 简单来说, 就是要"基于物理渲染".

那么在实现这样一个 "Physical Based Renderer" 之前, 不妨先来看看现实世界的"实现原理".

总而言之, 现在的这个程序有太多理想的假设和简化, 渲染出的场景还不够真实, 更进一步来说, 是不足以模拟真实世界中人的视觉感知.那不妨先来看看人的视觉是怎么产生的.

在进入下一节之前, 让我们对式xx 的描述进行一些修改:


你可以以后再回过头来看这个修改的意义.




## 基于物理的渲染

让我们从这个场景开始讲起吧, 可以看到

## 场景一: 自发光

### 光是什么

### 颜色/能量

瞬间的能量分布, 严格一点来说, 就是单位时间的能量(不用一开始详细的讲)

### 人眼的成像原理

在分析人眼之前, 我们不妨先来看看相机的成像原理

当然, 在实际开发时, 我们一般把图像平面 Film 放在 Camera 前面, 这样更方便计算.

数码相机的简单理解
薄透镜
DCC, CMOS 传感器的工作原理


![](img/eye.jpg)

上面是一张人眼的示意图, 晶状体, 视网膜...比较, 我们可以直观的看到, 人眼的成像其实类似于数码相机, 视网膜接受到光信号后, 由大脑形成最后的视觉, 也就是各种各样的颜色. 这里有一点非常重要, 那就是颜色是在人的视觉中枢中形成的, 视网膜上接受的只是一段电磁波而已.

换句话说, **颜色是人的主观感觉, 可见光并不是颜色**

<!--
不知道读到这里, 您会不会有一点反应不过来, 
-->
笔者在第一次认识到这一点时, 是有点反应不过来的, 毕竟无论是自己长期的生活经验, 还是中学的光学课程, 都让笔者形成了可见光就是颜色的看法, 忽然要重新认识这两者的关系, 打破以往长期的生活经验, 还是有点不适应的.(多少有点像第一次听到相对论的概念一样)

这里不妨多举几个例子, 譬如狗只有..., 只能看到黑白的世界; 墨鱼/鸟类的视网膜上有四种感光细胞, 可以感知到更多的光线, 有比人眼更丰富的颜色; 蜜蜂能看到紫外线, 帮助它们寻找花粉...

**可见光是客观存在的**, 是空间中的一段电磁波. 而大千世界的生物具体感知到了什么, 则取决于它们自己, 具体到人类, 看到了颜色, **颜色是人的主观感受**

不过为了实现基于物理的渲染, 与笔者有着类似观念的读者们, 需要好好重新认识可见光和颜色的关系

## 光是什么

人眼所能看到的光, 是电磁波中 300nm 到 700nm 左右的一段, 也就是可见光是电磁波的一个子集. 那么电磁波具有什么样的属性呢? 频率和波长.

这个时候如果再联系光谱图, 

<!--
首先简单来说, 我们能看见物体, 是因为光线或经由空间中的介质(空气, 水)传播直接进入到了人眼, 或经由物体表面的反射, 折射间接照射到人眼
-->


## 场景二: 直接光照

```C++
// ...

class Renderer
{
    void render(const Scene& scene);
};
```

~熟悉微积分的同学也许能很快意识到, 我们要计算的直接光照, 其实是一个积分方程. 但考虑到应该有不少人~我们从单个点光源开始拓展, 当在场景中增加光源时, 原来单个光源的计算, 变成了以下的求和:

formula




### 求解反射方程

限于篇幅, 这里暂且先略过蒙特卡洛积分的推导过程, 只从概念上帮助大家来理解.
<!--TODO
~~限于篇幅, 这里暂且先略过蒙特卡洛积分的推导过程, 只从概念上帮助大家来理解.~~
-->

## small pbrt

"我无法实现的, 我就无法理解" -- 费曼

这篇文章写了这么长, 都还没提到所谓的"pbrt-v3 阅读笔记", 现在我们可以回到正题, 

来实现一个麻雀版的 pbrt 了

```C++
// 极为简化的 pbrt-v3, 即 small_pbrt_v1:

class Light;
class Camera;
class Model;

class Scene
{
    Camera camera;
    Light  lights[];
    Model  models[];
};

class Renderer
{
    void render(const Scene& scene);
};
```

目前这个程序只有一堆接口, 主要是为了表达概念, ~还无法运行, 在下一篇文章里笔者会尝试去实现一个可以跑起来的程序~没有给出实现, 在下一篇文章中, 我们将结合具体的代码来讲解. 另外对文中的错漏之处, 欢迎各位读者批评指正, 笔者也将持续改进本系列文章.

## 资源

ray tracing essential(中文字幕): 光线跟踪历史简介
光线跟踪进化史: <全局光照技术>一书中对光线跟踪的历史简介

An Explanation of the Rendering Equation: 反射方程的视频介绍
